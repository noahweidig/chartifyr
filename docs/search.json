[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "A graduate student, self-proclaimed R enthusiast, and landscape ecologist. Welcome to ChartifyR!\nHere, I share insights on R programming, ecological research, and data-driven storytelling. From coding tips to exploring the dynamics of our changing landscapes, this space blends science, analysis, and creativity for curious minds."
  },
  {
    "objectID": "about.html#hi-im-noah",
    "href": "about.html#hi-im-noah",
    "title": "About",
    "section": "",
    "text": "A graduate student, self-proclaimed R enthusiast, and landscape ecologist. Welcome to ChartifyR!\nHere, I share insights on R programming, ecological research, and data-driven storytelling. From coding tips to exploring the dynamics of our changing landscapes, this space blends science, analysis, and creativity for curious minds."
  },
  {
    "objectID": "posts/ggplot-basics/index.html",
    "href": "posts/ggplot-basics/index.html",
    "title": "Basics of ggplot2",
    "section": "",
    "text": "Artwork by @allison_horst\nNothing is worse than reading a scientific publication only to encounter muddled, overly busy figures. Clear storytelling is a cornerstone of scientific writing, and the saying “a picture is worth a thousand words” has never been more relevant. Let’s dive into creating clean, effective figures in R!"
  },
  {
    "objectID": "posts/ggplot-basics/index.html#exporting-figures",
    "href": "posts/ggplot-basics/index.html#exporting-figures",
    "title": "Basics of ggplot2",
    "section": "Exporting Figures",
    "text": "Exporting Figures\nNow let’s save our figure. Most journals require between 300-600 dots per inch (dpi).\n\n\nCode\nggsave(\"penguins_histogram.jpg\", width = 5, height = 3, dpi = 300)\n\n\nAnd that’s it! Thanks for reading! Look out for more R tutorials."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To ChartifyR",
    "section": "",
    "text": "I’m excited to share my knowledge of data science and visualization using R, specifically the tidyverse suite of packages, as well as other languages and tools.\n\n\n\nArtwork by @allison_horst"
  },
  {
    "objectID": "posts/dplyr-basics/index.html",
    "href": "posts/dplyr-basics/index.html",
    "title": "Basics of dplyr",
    "section": "",
    "text": "Artwork by @allison_horst\n\n\nIf you’ve ever worked with messy data in R, you know how painful base R subsetting can be. The dplyr package makes data wrangling intuitive and readable. In this tutorial, we’ll walk through the six core dplyr verbs using the Palmer Penguins dataset.\n\nSetup\nLet’s load the packages we need.\n\n\nCode\n# Uncomment and run these once\n#install.packages(\"tidyverse\")\n#install.packages(\"palmerpenguins\")\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\n\nLet’s take a look at the data.\n\n\nCode\npenguins\n\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nWe have 344 penguins with 8 variables: species, island, bill measurements, flipper length, body mass, sex, and year.\n\n\nThe Pipe Operator\nBefore we dive into the verbs, let’s talk about the pipe: |&gt; (or %&gt;%). The pipe takes the output of one function and passes it as the first argument to the next. This lets us chain operations together in a readable way.\n\n\nCode\n# Without the pipe\nnrow(penguins)\n\n\n[1] 344\n\n\nCode\n# With the pipe — same result\npenguins |&gt; nrow()\n\n\n[1] 344\n\n\nYou’ll see the pipe used throughout this tutorial. Think of it as saying “and then…”\n\n\nfilter()\nfilter() keeps rows that match a condition. Let’s grab only the Adelie penguins.\n\n\nCode\npenguins |&gt;\n  filter(species == \"Adelie\")\n\n\n# A tibble: 152 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 142 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nYou can combine multiple conditions. Let’s find Adelie penguins that weigh more than 4000 grams.\n\n\nCode\npenguins |&gt;\n  filter(species == \"Adelie\", body_mass_g &gt; 4000)\n\n\n# A tibble: 35 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.2          19.6               195        4675\n 2 Adelie  Torgersen           42            20.2               190        4250\n 3 Adelie  Torgersen           34.6          21.1               198        4400\n 4 Adelie  Torgersen           42.5          20.7               197        4500\n 5 Adelie  Torgersen           46            21.5               194        4200\n 6 Adelie  Dream               39.2          21.1               196        4150\n 7 Adelie  Dream               39.8          19.1               184        4650\n 8 Adelie  Dream               44.1          19.7               196        4400\n 9 Adelie  Dream               39.6          18.8               190        4600\n10 Adelie  Dream               42.3          21.2               191        4150\n# ℹ 25 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nUse | (or) for either/or conditions.\n\n\nCode\npenguins |&gt;\n  filter(island == \"Biscoe\" | island == \"Dream\")\n\n\n# A tibble: 292 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Biscoe           37.8          18.3               174        3400\n 2 Adelie  Biscoe           37.7          18.7               180        3600\n 3 Adelie  Biscoe           35.9          19.2               189        3800\n 4 Adelie  Biscoe           38.2          18.1               185        3950\n 5 Adelie  Biscoe           38.8          17.2               180        3800\n 6 Adelie  Biscoe           35.3          18.9               187        3800\n 7 Adelie  Biscoe           40.6          18.6               183        3550\n 8 Adelie  Biscoe           40.5          17.9               187        3200\n 9 Adelie  Biscoe           37.9          18.6               172        3150\n10 Adelie  Biscoe           40.5          18.9               180        3950\n# ℹ 282 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nA cleaner way to filter for multiple values is %in%.\n\n\nCode\npenguins |&gt;\n  filter(island %in% c(\"Biscoe\", \"Dream\"))\n\n\n# A tibble: 292 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Biscoe           37.8          18.3               174        3400\n 2 Adelie  Biscoe           37.7          18.7               180        3600\n 3 Adelie  Biscoe           35.9          19.2               189        3800\n 4 Adelie  Biscoe           38.2          18.1               185        3950\n 5 Adelie  Biscoe           38.8          17.2               180        3800\n 6 Adelie  Biscoe           35.3          18.9               187        3800\n 7 Adelie  Biscoe           40.6          18.6               183        3550\n 8 Adelie  Biscoe           40.5          17.9               187        3200\n 9 Adelie  Biscoe           37.9          18.6               172        3150\n10 Adelie  Biscoe           40.5          18.9               180        3950\n# ℹ 282 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n\nselect()\nselect() picks specific columns. This is useful when you only need a few variables from a wide dataset.\n\n\nCode\npenguins |&gt;\n  select(species, island, body_mass_g)\n\n\n# A tibble: 344 × 3\n   species island    body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;           &lt;int&gt;\n 1 Adelie  Torgersen        3750\n 2 Adelie  Torgersen        3800\n 3 Adelie  Torgersen        3250\n 4 Adelie  Torgersen          NA\n 5 Adelie  Torgersen        3450\n 6 Adelie  Torgersen        3650\n 7 Adelie  Torgersen        3625\n 8 Adelie  Torgersen        4675\n 9 Adelie  Torgersen        3475\n10 Adelie  Torgersen        4250\n# ℹ 334 more rows\n\n\nYou can also remove columns with a minus sign.\n\n\nCode\npenguins |&gt;\n  select(-year)\n\n\n# A tibble: 344 × 7\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 1 more variable: sex &lt;fct&gt;\n\n\nThere are handy helper functions too. starts_with() grabs columns that start with a string.\n\n\nCode\npenguins |&gt;\n  select(species, starts_with(\"bill\"))\n\n\n# A tibble: 344 × 3\n   species bill_length_mm bill_depth_mm\n   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;\n 1 Adelie            39.1          18.7\n 2 Adelie            39.5          17.4\n 3 Adelie            40.3          18  \n 4 Adelie            NA            NA  \n 5 Adelie            36.7          19.3\n 6 Adelie            39.3          20.6\n 7 Adelie            38.9          17.8\n 8 Adelie            39.2          19.6\n 9 Adelie            34.1          18.1\n10 Adelie            42            20.2\n# ℹ 334 more rows\n\n\n\n\nmutate()\nmutate() creates new columns or modifies existing ones. Let’s convert body mass from grams to kilograms.\n\n\nCode\npenguins |&gt;\n  mutate(body_mass_kg = body_mass_g / 1000) |&gt;\n  select(species, body_mass_g, body_mass_kg)\n\n\n# A tibble: 344 × 3\n   species body_mass_g body_mass_kg\n   &lt;fct&gt;         &lt;int&gt;        &lt;dbl&gt;\n 1 Adelie         3750         3.75\n 2 Adelie         3800         3.8 \n 3 Adelie         3250         3.25\n 4 Adelie           NA        NA   \n 5 Adelie         3450         3.45\n 6 Adelie         3650         3.65\n 7 Adelie         3625         3.62\n 8 Adelie         4675         4.68\n 9 Adelie         3475         3.48\n10 Adelie         4250         4.25\n# ℹ 334 more rows\n\n\nYou can create multiple columns at once.\n\n\nCode\npenguins |&gt;\n  mutate(\n    body_mass_kg = body_mass_g / 1000,\n    bill_ratio = bill_length_mm / bill_depth_mm\n  ) |&gt;\n  select(species, body_mass_kg, bill_ratio)\n\n\n# A tibble: 344 × 3\n   species body_mass_kg bill_ratio\n   &lt;fct&gt;          &lt;dbl&gt;      &lt;dbl&gt;\n 1 Adelie          3.75       2.09\n 2 Adelie          3.8        2.27\n 3 Adelie          3.25       2.24\n 4 Adelie         NA         NA   \n 5 Adelie          3.45       1.90\n 6 Adelie          3.65       1.91\n 7 Adelie          3.62       2.19\n 8 Adelie          4.68       2   \n 9 Adelie          3.48       1.88\n10 Adelie          4.25       2.08\n# ℹ 334 more rows\n\n\n\n\narrange()\narrange() sorts rows. By default, it sorts in ascending order.\n\n\nCode\npenguins |&gt;\n  arrange(body_mass_g)\n\n\n# A tibble: 344 × 8\n   species   island   bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;     &lt;fct&gt;             &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Chinstrap Dream              46.9          16.6               192        2700\n 2 Adelie    Biscoe             36.5          16.6               181        2850\n 3 Adelie    Biscoe             36.4          17.1               184        2850\n 4 Adelie    Biscoe             34.5          18.1               187        2900\n 5 Adelie    Dream              33.1          16.1               178        2900\n 6 Adelie    Torgers…           38.6          17                 188        2900\n 7 Chinstrap Dream              43.2          16.6               187        2900\n 8 Adelie    Biscoe             37.9          18.6               193        2925\n 9 Adelie    Dream              37.5          18.9               179        2975\n10 Adelie    Dream              37            16.9               185        3000\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nUse desc() for descending order.\n\n\nCode\npenguins |&gt;\n  arrange(desc(body_mass_g))\n\n\n# A tibble: 344 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Gentoo  Biscoe           49.2          15.2               221        6300\n 2 Gentoo  Biscoe           59.6          17                 230        6050\n 3 Gentoo  Biscoe           51.1          16.3               220        6000\n 4 Gentoo  Biscoe           48.8          16.2               222        6000\n 5 Gentoo  Biscoe           45.2          16.4               223        5950\n 6 Gentoo  Biscoe           49.8          15.9               229        5950\n 7 Gentoo  Biscoe           48.4          14.6               213        5850\n 8 Gentoo  Biscoe           49.3          15.7               217        5850\n 9 Gentoo  Biscoe           55.1          16                 230        5850\n10 Gentoo  Biscoe           49.5          16.2               229        5800\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nYou can sort by multiple columns. This sorts by species first, then by body mass within each species.\n\n\nCode\npenguins |&gt;\n  arrange(species, desc(body_mass_g))\n\n\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Biscoe              43.2          19                 197        4775\n 2 Adelie  Biscoe              41            20                 203        4725\n 3 Adelie  Torgersen           42.9          17.6               196        4700\n 4 Adelie  Torgersen           39.2          19.6               195        4675\n 5 Adelie  Dream               39.8          19.1               184        4650\n 6 Adelie  Dream               39.6          18.8               190        4600\n 7 Adelie  Biscoe              45.6          20.3               191        4600\n 8 Adelie  Torgersen           42.5          20.7               197        4500\n 9 Adelie  Dream               37.5          18.5               199        4475\n10 Adelie  Torgersen           41.8          19.4               198        4450\n# ℹ 334 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n\nsummarize()\nsummarize() (or summarise()) collapses the data into a summary. Let’s find the average body mass.\n\n\nCode\npenguins |&gt;\n  summarize(mean_mass = mean(body_mass_g, na.rm = TRUE))\n\n\n# A tibble: 1 × 1\n  mean_mass\n      &lt;dbl&gt;\n1     4202.\n\n\nThe na.rm = TRUE argument tells R to ignore missing values. You can compute multiple summaries at once.\n\n\nCode\npenguins |&gt;\n  summarize(\n    mean_mass = mean(body_mass_g, na.rm = TRUE),\n    sd_mass = sd(body_mass_g, na.rm = TRUE),\n    n = n()\n  )\n\n\n# A tibble: 1 × 3\n  mean_mass sd_mass     n\n      &lt;dbl&gt;   &lt;dbl&gt; &lt;int&gt;\n1     4202.    802.   344\n\n\n\n\ngroup_by()\ngroup_by() is where dplyr really shines. It splits the data into groups so that subsequent operations are performed per group. Pair it with summarize() for powerful grouped summaries.\n\n\nCode\npenguins |&gt;\n  group_by(species) |&gt;\n  summarize(\n    mean_mass = mean(body_mass_g, na.rm = TRUE),\n    sd_mass = sd(body_mass_g, na.rm = TRUE),\n    n = n()\n  )\n\n\n# A tibble: 3 × 4\n  species   mean_mass sd_mass     n\n  &lt;fct&gt;         &lt;dbl&gt;   &lt;dbl&gt; &lt;int&gt;\n1 Adelie        3701.    459.   152\n2 Chinstrap     3733.    384.    68\n3 Gentoo        5076.    504.   124\n\n\nYou can group by multiple variables.\n\n\nCode\npenguins |&gt;\n  group_by(species, island) |&gt;\n  summarize(\n    mean_mass = mean(body_mass_g, na.rm = TRUE),\n    n = n(),\n    .groups = \"drop\"\n  )\n\n\n# A tibble: 5 × 4\n  species   island    mean_mass     n\n  &lt;fct&gt;     &lt;fct&gt;         &lt;dbl&gt; &lt;int&gt;\n1 Adelie    Biscoe        3710.    44\n2 Adelie    Dream         3688.    56\n3 Adelie    Torgersen     3706.    52\n4 Chinstrap Dream         3733.    68\n5 Gentoo    Biscoe        5076.   124\n\n\nThe .groups = \"drop\" argument ungroups the data after summarizing, which is good practice.\n\n\nPutting It All Together\nThe real power of dplyr is chaining verbs together. Let’s find the average flipper length for each species, but only for female penguins weighing over 3500 grams, sorted from longest to shortest.\n\n\nCode\npenguins |&gt;\n  filter(sex == \"female\", body_mass_g &gt; 3500) |&gt;\n  group_by(species) |&gt;\n  summarize(\n    mean_flipper = mean(flipper_length_mm, na.rm = TRUE),\n    n = n()\n  ) |&gt;\n  arrange(desc(mean_flipper))\n\n\n# A tibble: 3 × 3\n  species   mean_flipper     n\n  &lt;fct&gt;            &lt;dbl&gt; &lt;int&gt;\n1 Gentoo            213.    58\n2 Chinstrap         192.    19\n3 Adelie            190.    22\n\n\nEach step is readable on its own, and the pipe makes the full pipeline easy to follow.\n\n\nQuick Reference\n\n\n\nVerb\nWhat it does\n\n\n\n\nfilter()\nKeep rows that match a condition\n\n\nselect()\nPick or remove columns\n\n\nmutate()\nCreate or modify columns\n\n\narrange()\nSort rows\n\n\nsummarize()\nCollapse data into summaries\n\n\ngroup_by()\nGroup data for per-group operations\n\n\n\nAnd that’s it! These six verbs will cover the vast majority of your data wrangling needs. Thanks for reading — keep an eye out for more R tutorials!"
  },
  {
    "objectID": "posts/dplyr-joins/index.html",
    "href": "posts/dplyr-joins/index.html",
    "title": "Mastering Joins in dplyr",
    "section": "",
    "text": "Combining two datasets sounds simple — until you get back twice as many rows as you expected, or half your data vanishes. Joins are one of the most useful operations in data analysis, but they’re also one of the easiest places to introduce silent bugs. This tutorial will walk you through the main dplyr join functions, show you exactly what each one does, and teach you how to spot problems before they ruin your analysis."
  },
  {
    "objectID": "posts/dplyr-joins/index.html#anti_join",
    "href": "posts/dplyr-joins/index.html#anti_join",
    "title": "Mastering Joins in dplyr",
    "section": "anti_join()",
    "text": "anti_join()\nanti_join() returns rows from the left table that have no match in the right table. It’s the best way to find what gets lost in a join.\n\n\nCode\n# Which observations have no habitat data?\nobservations |&gt;\n  anti_join(habitat, by = \"site_id\")\n\n\n# A tibble: 1 x 3\n  site_id species count\n  &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;\n1 D       Finch      15\n\n\n\n\nCode\n# Which habitats have no observations?\nhabitat |&gt;\n  anti_join(observations, by = \"site_id\")\n\n\n# A tibble: 1 x 3\n  site_id habitat_type elevation_m\n  &lt;chr&gt;   &lt;chr&gt;              &lt;dbl&gt;\n1 E       Desert               900\n\n\nRun anti_join() in both directions before doing your actual join. This tells you exactly what data is missing."
  },
  {
    "objectID": "posts/dplyr-joins/index.html#counting-keys",
    "href": "posts/dplyr-joins/index.html#counting-keys",
    "title": "Mastering Joins in dplyr",
    "section": "Counting keys",
    "text": "Counting keys\nAlways check whether your join key is unique before joining. If it isn’t, you may get unexpected row multiplication.\n\n\nCode\n# Check if site_id is unique in each table\nobservations |&gt;\n  count(site_id) |&gt;\n  filter(n &gt; 1)\n\n\n# A tibble: 0 x 2\n# i 2 variables: site_id &lt;chr&gt;, n &lt;int&gt;\n\n\nAn empty result means every key is unique — safe for a one-to-one or one-to-many join."
  },
  {
    "objectID": "posts/dplyr-joins/index.html#checking-row-counts-before-and-after",
    "href": "posts/dplyr-joins/index.html#checking-row-counts-before-and-after",
    "title": "Mastering Joins in dplyr",
    "section": "Checking row counts before and after",
    "text": "Checking row counts before and after\nA simple but effective diagnostic: compare nrow() before and after your join.\n\n\nCode\n# Before\nnrow(observations)\n\n\n[1] 4\n\n\nCode\n# After left_join\nresult &lt;- observations |&gt;\n  left_join(habitat, by = \"site_id\")\n\nnrow(result)\n\n\n[1] 4\n\n\nFor a left_join() with unique keys on the right, the row count should stay the same. If it goes up, you likely have duplicate keys in the right table. If it goes down (shouldn’t happen with left_join()), something unusual is going on."
  },
  {
    "objectID": "posts/data-cleaning-tidyr-stringr/index.html",
    "href": "posts/data-cleaning-tidyr-stringr/index.html",
    "title": "Data Cleaning in the Real World",
    "section": "",
    "text": "Artwork by @allison_horst\nYou know the drill. Someone hands you a spreadsheet with columns like cases_2019, cases_2020, cases_2021, values crammed into single cells, and mysterious NAs scattered everywhere. Before you can analyze anything, you need to clean it. This is where tidyr and stringr come in — and where most of your time as a data analyst actually goes.\nThis tutorial builds directly on Basics of dplyr. If you’re comfortable with filter(), mutate(), and the pipe, you’re ready."
  },
  {
    "objectID": "posts/data-cleaning-tidyr-stringr/index.html#pivoting-with-names_sep",
    "href": "posts/data-cleaning-tidyr-stringr/index.html#pivoting-with-names_sep",
    "title": "Data Cleaning in the Real World",
    "section": "Pivoting with names_sep",
    "text": "Pivoting with names_sep\nThose category values still pack three pieces of information into one string. We can split them during the pivot itself.\n\n\nCode\nwho_tidy &lt;- who2 |&gt;\n  pivot_longer(\n    cols = !c(country, year),\n    names_to = c(\"diagnosis\", \"sex\", \"age_group\"),\n    names_sep = \"_\",\n    values_to = \"count\",\n    values_drop_na = TRUE\n  )\n\nwho_tidy\n\n\n# A tibble: 76,046 × 6\n   country      year diagnosis sex   age_group count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt;\n 1 Afghanistan  1997 sp        m     014           0\n 2 Afghanistan  1997 sp        m     1524         10\n 3 Afghanistan  1997 sp        m     2534          6\n 4 Afghanistan  1997 sp        m     3544          3\n 5 Afghanistan  1997 sp        m     4554          5\n 6 Afghanistan  1997 sp        m     5564          2\n 7 Afghanistan  1997 sp        m     65            0\n 8 Afghanistan  1997 sp        f     014           5\n 9 Afghanistan  1997 sp        f     1524         38\n10 Afghanistan  1997 sp        f     2534         36\n# ℹ 76,036 more rows\n\n\nOne call and we went from a 56-column mess to a clean, long-format table with clearly named variables. That’s the power of pivot_longer()."
  },
  {
    "objectID": "posts/data-cleaning-tidyr-stringr/index.html#separate_wider_delim",
    "href": "posts/data-cleaning-tidyr-stringr/index.html#separate_wider_delim",
    "title": "Data Cleaning in the Real World",
    "section": "separate_wider_delim()",
    "text": "separate_wider_delim()\nSometimes a single column contains multiple values separated by a delimiter. Let’s manufacture a quick example to see separate_wider_delim() in action.\n\n\nCode\nmessy_locations &lt;- tibble(\n  id = 1:4,\n  location = c(\"USA-New York\", \"CAN-Toronto\", \"GBR-London\", \"AUS-Sydney\")\n)\n\nmessy_locations |&gt;\n  separate_wider_delim(\n    location,\n    delim = \"-\",\n    names = c(\"country_code\", \"city\")\n  )\n\n\n# A tibble: 4 × 3\n     id country_code city    \n  &lt;int&gt; &lt;chr&gt;        &lt;chr&gt;   \n1     1 USA          New York\n2     2 CAN          Toronto \n3     3 GBR          London  \n4     4 AUS          Sydney  \n\n\nThis cleanly splits one column into two. If the number of pieces isn’t consistent across rows, use too_few and too_many to control the behavior:\n\n\nCode\ntricky &lt;- tibble(\n  id = 1:3,\n  value = c(\"A-B-C\", \"D-E\", \"F-G-H-I\")\n)\n\ntricky |&gt;\n  separate_wider_delim(\n    value,\n    delim = \"-\",\n    names = c(\"first\", \"second\", \"third\"),\n    too_few = \"align_start\",\n    too_many = \"merge\"\n  )\n\n\n# A tibble: 3 × 4\n     id first second third\n  &lt;int&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;\n1     1 A     B      C    \n2     2 D     E      &lt;NA&gt; \n3     3 F     G      H-I  \n\n\nThe too_few = \"align_start\" fills missing pieces with NA from the right. The too_many = \"merge\" lumps extra pieces into the last column. This keeps your pipeline from crashing on messy, inconsistent data."
  },
  {
    "objectID": "posts/data-cleaning-tidyr-stringr/index.html#unite",
    "href": "posts/data-cleaning-tidyr-stringr/index.html#unite",
    "title": "Data Cleaning in the Real World",
    "section": "unite()",
    "text": "unite()\nunite() is the reverse — gluing columns together.\n\n\nCode\nwho_tidy |&gt;\n  unite(\"demographic\", sex, age_group, sep = \"_\") |&gt;\n  select(country, year, diagnosis, demographic, count) |&gt;\n  head()\n\n\n# A tibble: 6 × 5\n  country      year diagnosis demographic count\n  &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;\n1 Afghanistan  1997 sp        m_014           0\n2 Afghanistan  1997 sp        m_1524         10\n3 Afghanistan  1997 sp        m_2534          6\n4 Afghanistan  1997 sp        m_3544          3\n5 Afghanistan  1997 sp        m_4554          5\n6 Afghanistan  1997 sp        m_5564          2\n\n\nThis is handy when you need to create an interaction label for plotting or joining."
  },
  {
    "objectID": "posts/data-cleaning-tidyr-stringr/index.html#str_detect-finding-patterns",
    "href": "posts/data-cleaning-tidyr-stringr/index.html#str_detect-finding-patterns",
    "title": "Data Cleaning in the Real World",
    "section": "str_detect() — finding patterns",
    "text": "str_detect() — finding patterns\nstr_detect() returns TRUE or FALSE, making it perfect inside filter().\n\n\nCode\n# Which Star Wars characters have \"Skywalker\" in their name?\nstarwars |&gt;\n  filter(str_detect(name, \"Skywalker\"))\n\n\n# A tibble: 3 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1 Luke Sky…    172    77 blond      fair       blue            19   male  mascu…\n2 Anakin S…    188    84 blond      fair       blue            41.9 male  mascu…\n3 Shmi Sky…    163    NA black      fair       brown           72   fema… femin…\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\n\n\n\nCode\n# Find characters with multiple skin colors (contain a comma)\nstarwars |&gt;\n  filter(str_detect(skin_color, \",\")) |&gt;\n  select(name, skin_color)\n\n\n# A tibble: 14 × 2\n   name                  skin_color         \n   &lt;chr&gt;                 &lt;chr&gt;              \n 1 R2-D2                 white, blue        \n 2 R5-D4                 white, red         \n 3 Jabba Desilijic Tiure green-tan, brown   \n 4 Watto                 blue, grey         \n 5 Sebulba               grey, red          \n 6 Ratts Tyerel          grey, blue         \n 7 Dud Bolt              blue, grey         \n 8 Gasgano               white, blue        \n 9 Ben Quadinaros        grey, green, yellow\n10 Zam Wesell            fair, green, yellow\n11 R4-P17                silver, red        \n12 Wat Tambor            green, grey        \n13 Shaak Ti              red, blue, white   \n14 Grievous              brown, white"
  },
  {
    "objectID": "posts/data-cleaning-tidyr-stringr/index.html#str_replace-and-str_replace_all",
    "href": "posts/data-cleaning-tidyr-stringr/index.html#str_replace-and-str_replace_all",
    "title": "Data Cleaning in the Real World",
    "section": "str_replace() and str_replace_all()",
    "text": "str_replace() and str_replace_all()\nstr_replace() swaps the first match; str_replace_all() swaps every match. This is essential for cleaning up inconsistent labels.\n\n\nCode\nstarwars |&gt;\n  mutate(skin_color = str_replace_all(skin_color, \", \", \"/\")) |&gt;\n  filter(str_detect(skin_color, \"/\")) |&gt;\n  select(name, skin_color)\n\n\n# A tibble: 14 × 2\n   name                  skin_color       \n   &lt;chr&gt;                 &lt;chr&gt;            \n 1 R2-D2                 white/blue       \n 2 R5-D4                 white/red        \n 3 Jabba Desilijic Tiure green-tan/brown  \n 4 Watto                 blue/grey        \n 5 Sebulba               grey/red         \n 6 Ratts Tyerel          grey/blue        \n 7 Dud Bolt              blue/grey        \n 8 Gasgano               white/blue       \n 9 Ben Quadinaros        grey/green/yellow\n10 Zam Wesell            fair/green/yellow\n11 R4-P17                silver/red       \n12 Wat Tambor            green/grey       \n13 Shaak Ti              red/blue/white   \n14 Grievous              brown/white      \n\n\nA common use case: standardizing messy category labels.\n\n\nCode\nraw_labels &lt;- c(\"United States\", \"united states\", \"US\", \"U.S.\", \"usa\")\n\nraw_labels |&gt;\n  str_to_lower() |&gt;\n  str_replace_all(c(\n    \"^us$\"      = \"united states\",\n    \"^u\\\\.s\\\\.$\" = \"united states\",\n    \"^usa$\"      = \"united states\"\n  ))\n\n\n[1] \"united states\" \"united states\" \"united states\" \"united states\"\n[5] \"united states\""
  },
  {
    "objectID": "posts/data-cleaning-tidyr-stringr/index.html#str_extract-pulling-out-pieces",
    "href": "posts/data-cleaning-tidyr-stringr/index.html#str_extract-pulling-out-pieces",
    "title": "Data Cleaning in the Real World",
    "section": "str_extract() — pulling out pieces",
    "text": "str_extract() — pulling out pieces\nstr_extract() grabs the first matching portion of a string. Let’s pull the numeric age boundaries from our cleaned WHO data.\n\n\nCode\nwho_tidy |&gt;\n  mutate(\n    age_start = str_extract(age_group, \"^\\\\d+\") |&gt; as.integer()\n  ) |&gt;\n  distinct(age_group, age_start) |&gt;\n  arrange(age_start)\n\n\n# A tibble: 7 × 2\n  age_group age_start\n  &lt;chr&gt;         &lt;int&gt;\n1 014              14\n2 65               65\n3 1524           1524\n4 2534           2534\n5 3544           3544\n6 4554           4554\n7 5564           5564"
  },
  {
    "objectID": "posts/data-cleaning-tidyr-stringr/index.html#str_trim-and-str_squish",
    "href": "posts/data-cleaning-tidyr-stringr/index.html#str_trim-and-str_squish",
    "title": "Data Cleaning in the Real World",
    "section": "str_trim() and str_squish()",
    "text": "str_trim() and str_squish()\nWhitespace is the silent killer of joins and group-bys. Two rows that look identical can fail to match because one has a trailing space.\n\n\nCode\nmessy_names &lt;- c(\"  Alice \", \"Bob\", \" Charlie  \", \"  Alice\")\n\n# str_trim removes leading/trailing whitespace\nstr_trim(messy_names)\n\n\n[1] \"Alice\"   \"Bob\"     \"Charlie\" \"Alice\"  \n\n\nCode\n# str_squish also collapses internal whitespace\nstr_squish(\"  too   many   spaces  \")\n\n\n[1] \"too many spaces\"\n\n\nAlways trim your strings before joining or grouping. This one habit will save you hours of debugging."
  },
  {
    "objectID": "posts/data-cleaning-tidyr-stringr/index.html#factor-explosions",
    "href": "posts/data-cleaning-tidyr-stringr/index.html#factor-explosions",
    "title": "Data Cleaning in the Real World",
    "section": "Factor explosions",
    "text": "Factor explosions\nWhen you read a CSV, character columns sometimes get read as factors. This means levels() bakes in the exact set of unique values. If you then filter() down to a subset, the unused levels stick around as ghosts — inflating your legend in plots, adding empty groups in summaries, and generally causing confusion.\n\n\nCode\n# Simulate the problem\nspecies_factor &lt;- factor(c(\"cat\", \"dog\", \"bird\", \"cat\", \"dog\"))\nfiltered &lt;- species_factor[species_factor != \"bird\"]\n\n# \"bird\" is gone from the data but still in the levels\nlevels(filtered)\n\n\n[1] \"bird\" \"cat\"  \"dog\" \n\n\nCode\n# Fix: drop unused levels\nlevels(droplevels(filtered))\n\n\n[1] \"cat\" \"dog\"\n\n\nThe lesson: use droplevels() after filtering factor data, or better yet, keep text as character columns with stringsAsFactors = FALSE (the default since R 4.0) and convert to factors only when you need explicit ordering."
  },
  {
    "objectID": "posts/data-cleaning-tidyr-stringr/index.html#na-handling",
    "href": "posts/data-cleaning-tidyr-stringr/index.html#na-handling",
    "title": "Data Cleaning in the Real World",
    "section": "NA handling",
    "text": "NA handling\nMissing values propagate silently. Any arithmetic with NA returns NA. Any comparison with NA returns NA. This means filter(x == NA) never returns rows — use is.na() instead.\n\n\nCode\n# This returns nothing — NA == NA is NA, not TRUE\nstarwars |&gt;\n  filter(mass == NA) |&gt;\n  nrow()\n\n\n[1] 0\n\n\nCode\n# This is what you actually want\nstarwars |&gt;\n  filter(is.na(mass)) |&gt;\n  select(name, mass) |&gt;\n  head()\n\n\n# A tibble: 6 × 2\n  name            mass\n  &lt;chr&gt;          &lt;dbl&gt;\n1 Wilhuff Tarkin    NA\n2 Mon Mothma        NA\n3 Arvel Crynyd      NA\n4 Finis Valorum     NA\n5 Rugor Nass        NA\n6 Ric Olié          NA\n\n\nFor summaries, always pass na.rm = TRUE.\n\n\nCode\n# Without na.rm — returns NA\nstarwars |&gt;\n  summarize(avg_height = mean(height))\n\n\n# A tibble: 1 × 1\n  avg_height\n       &lt;dbl&gt;\n1         NA\n\n\nCode\n# With na.rm — returns the actual mean\nstarwars |&gt;\n  summarize(avg_height = mean(height, na.rm = TRUE))\n\n\n# A tibble: 1 × 1\n  avg_height\n       &lt;dbl&gt;\n1       175.\n\n\nIf you want to replace NAs with a default value, use replace_na() from tidyr.\n\n\nCode\nstarwars |&gt;\n  mutate(hair_color = replace_na(hair_color, \"unknown\")) |&gt;\n  count(hair_color, sort = TRUE) |&gt;\n  head()\n\n\n# A tibble: 6 × 2\n  hair_color     n\n  &lt;chr&gt;      &lt;int&gt;\n1 none          38\n2 brown         18\n3 black         13\n4 unknown        5\n5 white          4\n6 blond          3"
  },
  {
    "objectID": "posts/data-cleaning-tidyr-stringr/index.html#duplicate-rows",
    "href": "posts/data-cleaning-tidyr-stringr/index.html#duplicate-rows",
    "title": "Data Cleaning in the Real World",
    "section": "Duplicate rows",
    "text": "Duplicate rows\nBefore any analysis, always check for duplicates. distinct() keeps unique rows, and get_dupes() from the janitor package can identify which rows are repeated. Here’s the tidyverse approach:\n\n\nCode\nwho_tidy |&gt;\n  group_by(country, year, diagnosis, sex, age_group) |&gt;\n  filter(n() &gt; 1) |&gt;\n  nrow()\n\n\n[1] 0\n\n\nZero duplicates — good. When you do find them, decide whether to keep the first, last, or aggregate."
  },
  {
    "objectID": "posts/maps-ggplot-sf/index.html",
    "href": "posts/maps-ggplot-sf/index.html",
    "title": "Mapping with ggplot2 and sf",
    "section": "",
    "text": "Artwork by @allison_horst\n\n\nHave you ever made a map in ArcGIS, only to later realize that you made a mistake with your data and will have to remake the entire thing? That’s where the sf package in R comes in!\nLet’s load the sf and tidyverse packages.\n\n\nCode\n# Uncomment and run this only once\n#install.packages(\"sf\")\nlibrary(sf)\nlibrary(tidyverse)\n\n\nNow, we’ll need to load our data. We’ll use the North Carolina counties data built into the sf package.\n\n\nCode\nnc &lt;- st_read(system.file(\"shape/nc.shp\", package = \"sf\"))\n\n\nReading layer `nc' from data source \n  `/Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/sf/shape/nc.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 100 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n\n\nEvery sf object has a “geometry” column, which stores the coordinates of the point, line, or polygon. Now, let’s plot it. The ggplot2 package has a geom_sf option for simple features.\n\n\nCode\nggplot() + geom_sf(data = nc)\n\n\n\n\n\n\n\n\n\nCode\n# if that does not work, you may have to specify the geometry in the aesthetic\nggplot() + geom_sf(data = nc, aes(geometry = geometry))\n\n\n\n\n\n\n\n\n\nNot bad. I prefer to not see the latitude/longitude along the axes, so I frequently use theme_void().\n\n\nCode\nggplot() + geom_sf(data = nc) + theme_void()\n\n\n\n\n\n\n\n\n\nGreat! This dataset has several attributes related to births and infant deaths. We’ll use the SID79, which is the number of sudden infant deaths in the year 1979 for each county.\n\n\nCode\nggplot() + geom_sf(data = nc, aes(fill = SID79)) + theme_void()\n\n\n\n\n\n\n\n\n\nThe ggplot default colors are not my favorite. I prefer using brewer colors. The direction argument reverses the direction of color darkening so that darker indicates a higher value.\n\n\nCode\nggplot() + geom_sf(data = nc, aes(fill = SID79)) + theme_void() +\n  scale_fill_distiller(palette = \"YlOrBr\", direction = 1)\n\n\n\n\n\n\n\n\n\nWe can see quite clearly that a few counties in central North Carolina had a large number of sudden infant deaths in 1979. To clean up this map, let’s add a scale bar and north arrow (using the ggspatial package), and refine the labels.\n\n\nCode\nlibrary(ggspatial)\n\nggplot() +\n  geom_sf(data = nc, aes(fill = SID79)) +\n  theme_void() +\n  scale_fill_distiller(palette = \"YlOrBr\", direction = 1) +\n  annotation_scale(location = \"bl\", line_width = 1) +\n  annotation_north_arrow(style = north_arrow_fancy_orienteering(),\n                         location = \"tl\", \n                         height = unit(0.8, \"cm\"),\n                         width = unit(0.8, \"cm\")) +\n  labs(fill = \"SIDS 1979\")\n\n\n\n\n\n\n\n\n\nMuch better! The scale bar and north arrow size can be adjusted as needed. This mostly depends on how large you save the figure. These ggplot objects can be saved the same way as a regular plot.\n\n\nCode\nggsave(\"nc.jpg\", width = 5, height = 3, dpi = 300)\n\n\nAnd you’re done! You’ve created your first official map in R!\nThanks for joining me. Keep an eye out for more tutorials in R!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ChartifyR",
    "section": "",
    "text": "✨ R, Data Viz, and Ecological Storytelling\nHands-on tutorials for building publication-ready charts, maps, and data pipelines in R — from ggplot2 and sf to tidy data wrangling. Browse recent posts or filter by category to find what you need.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMastering Joins in dplyr\n\n\nUnderstanding left_join, inner_join, full_join, and common pitfalls\n\n\n\ncode\n\n\ndplyr\n\n\ntidyverse\n\n\n\nLearn how to combine datasets with dplyr joins — left_join, inner_join, full_join — and how to diagnose duplicate rows, missing keys, and NA surprises.\n\n\n\n\n\nFeb 25, 2025\n\n\n8 min\n\n\n\n\n\n\n\n\n\n\n\n\nData Cleaning in the Real World\n\n\nFrom messy CSVs to analysis-ready tables with tidyr and stringr\n\n\n\ncode\n\n\ntidyverse\n\n\n\nLearn how to reshape, split, and clean messy data using tidyr and stringr — pivoting, separating columns, pattern matching, and handling common gotchas.\n\n\n\n\n\nFeb 22, 2025\n\n\n8 min\n\n\n\n\n\n\n\n\n\n\n\n\nBasics of dplyr\n\n\nA beginners guide to data wrangling in R\n\n\n\ncode\n\n\ndplyr\n\n\ntidyverse\n\n\n\nLearn the core dplyr verbs — filter, select, mutate, arrange, summarize, and group_by — using the Palmer Penguins dataset.\n\n\n\n\n\nFeb 15, 2025\n\n\n4 min\n\n\n\n\n\n\n\n\n\n\n\n\nMapping with ggplot2 and sf\n\n\nA simple guide to creating elegant maps in R\n\n\n\ncode\n\n\nggplot2\n\n\ndataviz\n\n\nsf\n\n\n\nCreate beautiful maps in R using ggplot2 and the sf package — from basic polygons to customized choropleth maps with scale bars.\n\n\n\n\n\nFeb 14, 2025\n\n\n3 min\n\n\n\n\n\n\n\n\n\n\n\n\nBasics of ggplot2\n\n\nA beginners guide to making figures in R\n\n\n\ncode\n\n\nggplot2\n\n\ndataviz\n\n\n\nLearn the fundamentals of ggplot2 — from basic histograms to colorful, labeled figures using the Palmer Penguins dataset.\n\n\n\n\n\nFeb 13, 2025\n\n\n4 min\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To ChartifyR\n\n\n\n\n\n\nnews\n\n\n\nIntroducing ChartifyR — a space for sharing data science and visualization techniques using R and the tidyverse.\n\n\n\n\n\nFeb 10, 2025\n\n\n1 min\n\n\n\n\n\n\nNo matching items"
  }
]